/**
 * Service d'import progressif des fichiers RNB
 * Parse les fichiers CSV volumineux et les indexe progressivement dans la base de données
 */

import { RNBService } from './rnb-service'
import { RNBIndexer } from './rnb-indexer'
import type { RNBBuildingData } from './rnb-service'

export interface ImportOptions {
  department: string
  maxRows?: number // Limite pour tester ou import partiel
  batchSize?: number // Taille des batches d'indexation
  onProgress?: (progress: { processed: number; total?: number; percentage: number }) => void
}

export class RNBImporter {
  private rnbService: RNBService
  private indexer: RNBIndexer

  constructor() {
    this.rnbService = new RNBService()
    this.indexer = new RNBIndexer()
  }

  /**
   * Importe un département complet depuis data.gouv.fr
   * Télécharge le fichier CSV, le parse et l'indexe progressivement
   */
  async importDepartment(options: ImportOptions): Promise<{ success: boolean; indexed: number; errors: number }> {
    const { department, maxRows, batchSize: _batchSize = 1000, onProgress: _onProgress } = options // batchSize et onProgress réservés pour usage futur (parsing CSV)

    try {
      // 1. Récupérer la ressource RNB pour ce département
      const resource = await this.rnbService.getDepartmentResource(department)
      if (!resource) {
        throw new Error(`Aucune ressource RNB trouvée pour le département ${department}`)
      }

      // 2. Créer un job d'import
      const jobId = await this.indexer.createImportJob(department, resource.url, resource.id)
      await this.indexer.updateImportJob(jobId, { status: 'IN_PROGRESS' })

      // 3. Télécharger et parser le fichier CSV
      console.log(`[RNBImporter] Début import département ${department} depuis ${resource.url}`)

      let indexed = 0
      let errors = 0
      const totalRows = maxRows || undefined

      try {
        // Télécharger le fichier ZIP
        const zipResponse = await fetch(resource.url)
        if (!zipResponse.ok) {
          throw new Error(`Erreur téléchargement: ${zipResponse.statusText}`)
        }

        // TODO: Décompresser le ZIP et parser le CSV
        // const zipBuffer = await zipResponse.arrayBuffer()
        // Pour l'instant, on simule un import progressif

        // Simulation d'un parsing progressif
        // En production, utiliser une bibliothèque comme 'csv-parser' ou 'papaparse'
        // avec traitement stream pour éviter de charger tout le fichier en mémoire

        console.warn('[RNBImporter] Le parsing CSV complet nécessite une bibliothèque externe')
        console.warn('[RNBImporter] Import partiel simulé pour le département', department)

        // Exemple de structure pour un vrai parsing :
        // const csvStream = createReadStream(csvFilePath).pipe(csv())
        // const buildings: RNBBuildingData[] = []
        // 
        // for await (const row of csvStream) {
        //   const buildingData = this.parseCSVRow(row, department)
        //   if (buildingData) {
        //     buildings.push(buildingData)
        //     
        //     if (buildings.length >= batchSize) {
        //       const result = await this.indexer.indexBuildingsBatch(buildings)
        //       indexed += result.success
        //       errors += result.failed
        //       buildings.length = 0 // Clear array
        //       
        //       // Callback de progression
        //       if (onProgress) {
        //         onProgress({
        //           processed: indexed + errors,
        //           total: totalRows,
        //           percentage: totalRows ? ((indexed + errors) / totalRows) * 100 : 0,
        //         })
        //       }
        //     }
        //   }
        // }

        // Pour l'instant, retourner un résultat simulé
        indexed = 0
        errors = 0

        await this.indexer.updateImportJob(jobId, {
          status: 'COMPLETED',
          progress: 100,
          processedRows: indexed,
          totalRows: totalRows || indexed,
        })
      } catch (error) {
        console.error(`[RNBImporter] Erreur import département ${department}:`, error)
        await this.indexer.updateImportJob(jobId, {
          status: 'FAILED',
          errorMessage: error instanceof Error ? error.message : 'Unknown error',
        })
        throw error
      }

      return { success: true, indexed, errors }
    } catch (error) {
      console.error('[RNBImporter] Erreur import département:', error)
      return { success: false, indexed: 0, errors: 1 }
    }
  }

  /**
   * Importe un bâtiment spécifique depuis le CSV (appel ponctuel)
   * Utile pour récupérer des données à la demande
   */
  async importSingleBuilding(
    _department: string, // Réservé pour usage futur (parsing CSV par département)
    searchCriteria: { postalCode?: string; address?: string; coordinates?: { lat: number; lng: number } }
  ): Promise<RNBBuildingData | null> {
    try {
      // 1. Vérifier d'abord dans l'index local
      const existing = await this.indexer.searchBuilding(
        searchCriteria.postalCode,
        searchCriteria.address,
        searchCriteria.coordinates
      )

      if (existing) {
        return existing
      }

      // 2. Si pas trouvé, récupérer depuis le CSV (nécessite parsing)
      // Pour l'instant, retourner null car le parsing CSV complet n'est pas implémenté
      console.warn('[RNBImporter] Import ponctuel nécessite le parsing CSV complet')
      return null
    } catch (error) {
      console.error('[RNBImporter] Erreur import bâtiment unique:', error)
      return null
    }
  }

  /**
   * Parse une ligne CSV RNB en RNBBuildingData
   * À adapter selon le format réel du CSV RNB
   */
  private parseCSVRow(row: any, department: string): RNBBuildingData | null {
    try {
      // Exemple de structure (à adapter selon le format réel du CSV RNB)
      return {
        id: row.id_rnb || row.id || `rnb-${department}-${row.index}`,
        department,
        codeINSEE: row.code_insee || row.code_insee_com,
        commune: row.nom_commune || row.commune,
        address: row.adresse || row.adresse_complete,
        postalCode: row.code_postal || row.cp,
        coordinates: row.latitude && row.longitude
          ? {
              lat: parseFloat(row.latitude),
              lng: parseFloat(row.longitude),
            }
          : undefined,
        constructionYear: row.annee_construction ? parseInt(row.annee_construction) : undefined,
        buildingType: row.type_batiment || row.nature_logement,
        surface: row.surface ? parseFloat(row.surface) : undefined,
        dpeClass: row.classe_dpe || row.dpe_classe,
        dpeDate: row.date_dpe ? new Date(row.date_dpe) : undefined,
        energyConsumption: row.conso_energie ? parseFloat(row.conso_energie) : undefined,
        ghgEmissions: row.emission_ges ? parseFloat(row.emission_ges) : undefined,
        hvd: row.hvd === '1' || row.hvd === 'true' || row.haute_valeur_determinante === '1',
        sources: ['RNB data.gouv.fr'],
        lastUpdated: new Date().toISOString(),
      }
    } catch (error) {
      console.error('[RNBImporter] Erreur parsing ligne CSV:', error)
      return null
    }
  }

  /**
   * Lance l'import progressif de plusieurs départements
   */
  async importDepartments(
    departments: string[],
    options?: { maxRowsPerDepartment?: number; concurrent?: number }
  ): Promise<Record<string, { success: boolean; indexed: number; errors: number }>> {
    const results: Record<string, { success: boolean; indexed: number; errors: number }> = {}

    // Importer séquentiellement pour éviter de surcharger
    for (const dept of departments) {
      console.log(`[RNBImporter] Import département ${dept}...`)
      results[dept] = await this.importDepartment({
        department: dept,
        maxRows: options?.maxRowsPerDepartment,
        onProgress: (progress) => {
          console.log(`[RNBImporter] Département ${dept}: ${progress.percentage.toFixed(1)}%`)
        },
      })
    }

    return results
  }
}

